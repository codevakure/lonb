"""
Product Management Service

This module provides business logic for loan product management and c        """
        Retrieve customers (bookings) filtered by product name
        
        Args:
            product_name: Product identifier to filter by
            headers: Texas Capital standard headers
            
        Returns:
            CustomersByProductResponse: Customer bookings for the product
        """oking operations, following Texas Capital service architecture patterns.
"""

import logging
from typing import List, Dict, Any, Optional
from datetime import datetime
import boto3
from botocore.exceptions import ClientError

from api.models.product_models import (
    SimpleProduct, 
    ProductListResponse, 
    CustomerBooking, 
    CustomersByProductResponse
)
from config.config_kb_loan import AWS_REGION, LOAN_BOOKING_TABLE_NAME
from utils.tc_standards import TCLogger, TCStandardHeaders

logger = logging.getLogger(__name__)


class ProductService:
    """
    Product Management Service
    
    Handles all business logic related to loan products and customer bookings.
    Provides methods for product retrieval, customer filtering, and analytics.
    """

    def __init__(self):
        """Initialize ProductService with AWS resources"""
        self.dynamodb = boto3.resource('dynamodb', region_name=AWS_REGION)
        self.bookings_table = self.dynamodb.Table(LOAN_BOOKING_TABLE_NAME)
        
        # Simple product catalog matching coretex schema
        self._products_catalog = [
            SimpleProduct(
                productId="equipment-financing",
                productName="Equipment Financing",
                dataSourceLocation="s3://loan-bucket/equipment-financing/"
            ),
            SimpleProduct(
                productId="term-loans",
                productName="Term Loans",
                dataSourceLocation="s3://loan-bucket/term-loans/"
            ),
            SimpleProduct(
                productId="working-capital-loans",
                productName="Working Capital Loans",
                dataSourceLocation="s3://loan-bucket/working-capital-loans/"
            )
        ]

    async def get_all_products(
        self,
        headers: Optional[TCStandardHeaders] = None
    ) -> ProductListResponse:
        """
        Retrieve all available loan products
        
        Args:
            headers: Texas Capital standard headers for tracing
            
        Returns:
            ProductListResponse: Simple product listing
        """
        try:
            TCLogger.log_info(
                "Retrieving loan products", 
                headers, 
                {"total_products": len(self._products_catalog)}
            )

            response = ProductListResponse(
                products=self._products_catalog,
                total=len(self._products_catalog)
            )
            
            TCLogger.log_success(
                "Products retrieved successfully", 
                headers, 
                {"total_products": len(self._products_catalog)}
            )
            
            return response
            
        except Exception as e:
            TCLogger.log_error(
                "Product retrieval failed", 
                e, 
                headers,
                {"service": "ProductService.get_all_products"}
            )
            raise

    async def get_customers_by_product(
        self, 
        product_name: str,
        headers: Optional[TCStandardHeaders] = None
    ) -> CustomersByProductResponse:
        """
        Retrieve customers (bookings) filtered by product name
        
        Args:
            product_name: Product identifier to filter by
            headers: Texas Capital standard headers
            
        Returns:
            CustomersByProductResponse: Customer bookings for the product
        """
        try:
            TCLogger.log_info(
                "Retrieving customers by product", 
                headers, 
                {
                    "product_name": product_name,
                    "filter_applied": customer_filter is not None
                }
            )

            # Validate product exists
            if product_name not in [p.id for p in self._products_catalog.values()]:
                raise ValueError(f"Invalid product name: {product_name}")

            # Query DynamoDB for bookings
            try:
                response = self.bookings_table.scan(
                    FilterExpression='productName = :p',
                    ExpressionAttributeValues={':p': product_name}
                )
                booking_items = response.get('Items', [])
                
            except ClientError as e:
                logger.error(f"DynamoDB scan failed: {e}")
                raise Exception(f"Failed to retrieve customer bookings: {e}")

            # Convert DynamoDB items to CustomerBooking models
            customers = []
            for item in booking_items:
                try:
                    customer = CustomerBooking(
                        loan_booking_id=item.get('loanBookingId', ''),
                        customer_name=item.get('customerName', ''),
                        product_name=item.get('productName', ''),
                        data_source_location=item.get('dataSourceLocation', ''),
                        document_ids=item.get('documentIds', []),
                        booking_status=item.get('status', 'pending'),
                        created_timestamp=item.get('timestamp'),
                        metadata=item.get('metadata', {})
                    )
                    customers.append(customer)
                except Exception as e:
                    logger.warning(f"Failed to parse booking item: {e}")
                    continue

            # Apply additional filters if provided
            if customer_filter:
                if customer_filter.status:
                    customers = [c for c in customers if c.booking_status == customer_filter.status]
                    
                if customer_filter.date_from:
                    from_timestamp = int(customer_filter.date_from.timestamp())
                    customers = [c for c in customers if c.created_timestamp and c.created_timestamp >= from_timestamp]
                    
                if customer_filter.date_to:
                    to_timestamp = int(customer_filter.date_to.timestamp())
                    customers = [c for c in customers if c.created_timestamp and c.created_timestamp <= to_timestamp]

            # Apply pagination
            total_customers = len(customers)
            if customer_filter and customer_filter.offset:
                customers = customers[customer_filter.offset:]
            if customer_filter and customer_filter.limit:
                customers = customers[:customer_filter.limit]

            # Generate summary statistics
            summary = self._generate_customer_summary(customers, total_customers)

            response = CustomersByProductResponse(
                product_name=product_name,
                customers=customers,
                total_customers=total_customers,
                summary=summary
            )
            
            TCLogger.log_success(
                "Customers retrieved successfully", 
                headers, 
                {
                    "product_name": product_name,
                    "total_customers": total_customers,
                    "returned_customers": len(customers)
                }
            )
            
            return response
            
        except ValueError as ve:
            TCLogger.log_warning(
                "Invalid product name provided", 
                headers, 
                {"product_name": product_name, "error": str(ve)}
            )
            raise
            
        except Exception as e:
            TCLogger.log_error(
                "Customer retrieval by product failed", 
                e, 
                headers,
                {"product_name": product_name}
            )
            raise

    def _generate_customer_summary(self, customers: List[CustomerBooking], total_count: int) -> Dict[str, Any]:
        """Generate summary statistics for customer bookings"""
        status_counts = {}
        document_count = 0
        
        for customer in customers:
            # Count by status
            status = customer.booking_status
            status_counts[status] = status_counts.get(status, 0) + 1
            
            # Count documents
            document_count += len(customer.document_ids)
        
        return {
            "total_customers": total_count,
            "status_breakdown": status_counts,
            "total_document_count": document_count,
            "average_documents_per_customer": round(document_count / len(customers), 2) if customers else 0
        }

    def get_product_s3_prefix(self, product_id: str) -> Optional[str]:
        """Get S3 folder prefix for a product"""
        for product in self._products_catalog.values():
            if product.id == product_id:
                return product.s3_folder_prefix
        return None
